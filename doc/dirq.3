.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "dirq 3"
.TH dirq 3 "2017-08-04" "dirq 0.5" ""
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
dirq \- C implementation of the simple directory queue algorithm
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  /*
\&   * constants
\&   */
\&
\&  #define DIRQ_VERSION_MAJOR 0
\&  #define DIRQ_VERSION_MINOR 5
\&  #define DIRQ_VERSION_HEX ((DIRQ_VERSION_MAJOR << 8) | DIRQ_VERSION_MINOR)
\&
\&  /*
\&   * types
\&   */
\&
\&  typedef struct dirq_s *dirq_t;
\&  typedef int (*dirq_iow)(dirq_t, char *, size_t);
\&  typedef int (*dirq_ior)(dirq_t, const char *, size_t);
\&
\&  /*
\&   * constructors & destructor
\&   */
\&
\&  dirq_t dirq_new  (const char *path);
\&  dirq_t dirq_copy (dirq_t dirq);
\&  void   dirq_free (dirq_t dirq);
\&
\&  /*
\&   * accessors
\&   */
\&
\&  void   dirq_set_granularity (dirq_t dirq, int value);
\&  int    dirq_get_granularity (dirq_t dirq);
\&  void   dirq_set_rndhex      (dirq_t dirq, int value);
\&  int    dirq_get_rndhex      (dirq_t dirq);
\&  void   dirq_set_umask       (dirq_t dirq, mode_t value);
\&  mode_t dirq_get_umask       (dirq_t dirq);
\&  void   dirq_set_maxlock     (dirq_t dirq, int value);
\&  int    dirq_get_maxlock     (dirq_t dirq);
\&  void   dirq_set_maxtemp     (dirq_t dirq, int value);
\&  int    dirq_get_maxtemp     (dirq_t dirq);
\&
\&  /*
\&   * iterators
\&   */
\&
\&  const char *dirq_first (dirq_t dirq);
\&  const char *dirq_next  (dirq_t dirq);
\&
\&  /*
\&   * main methods
\&   */
\&
\&  const char *dirq_add      (dirq_t dirq, dirq_iow cb);
\&  const char *dirq_add_path (dirq_t dirq, const char *path);
\&  int         dirq_get      (dirq_t dirq, const char *name, dirq_ior cb);
\&  const char *dirq_get_path (dirq_t dirq, const char *name);
\&  int         dirq_lock     (dirq_t dirq, const char *name, int permissive);
\&  int         dirq_unlock   (dirq_t dirq, const char *name, int permissive);
\&  int         dirq_remove   (dirq_t dirq, const char *name);
\&  int         dirq_touch    (dirq_t dirq, const char *name);
\&  int         dirq_get_size (dirq_t dirq, const char *name);
\&  int         dirq_count    (dirq_t dirq);
\&  int         dirq_purge    (dirq_t dirq);
\&
\&  /*
\&   * other methods
\&   */
\&
\&  void        dirq_now         (dirq_t dirq, struct timespec *ts);
\&  int         dirq_get_errcode (dirq_t dirq);
\&  const char *dirq_get_errstr  (dirq_t dirq);
\&  void        dirq_clear_error (dirq_t dirq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The goal of this library is to offer a \*(L"simple\*(R" queue system using the
underlying filesystem for storage, security and to prevent race conditions
via atomic operations. It focuses on simplicity, robustness and scalability.
.PP
Multiple concurrent readers and writers can interact with the same queue.
.PP
Other implementations of the same algorithm exist so readers and writers can
be written in different programming languages:
.IP "C: <https://github.com/cern\-mig/c\-dirq>" 4
.IX Item "C: <https://github.com/cern-mig/c-dirq>"
.PD 0
.IP "Java: <https://github.com/cern\-mig/java\-dirq>" 4
.IX Item "Java: <https://github.com/cern-mig/java-dirq>"
.IP "Perl: <http://search.cpan.org/dist/Directory\-Queue/>" 4
.IX Item "Perl: <http://search.cpan.org/dist/Directory-Queue/>"
.IP "Python: <https://github.com/cern\-mig/python\-dirq>" 4
.IX Item "Python: <https://github.com/cern-mig/python-dirq>"
.PD
.PP
The Perl implementation is the reference one and contains extensive
documentation.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
The object oriented \s-1API\s0 to access the directory queue is implemented with an
opaque data type (\f(CW\*(C`dirq_t\*(C'\fR), a constructor (\f(CW\*(C`dirq_new\*(C'\fR) and methods which
are C functions requiring the \*(L"object\*(R" as their first argument. The destructor
(\f(CW\*(C`dirq_free\*(C'\fR) must be called when the object is not needed anymore.
.PP
The directory queue object is not considered to be thread safe: different
threads must use different objects.
.PP
All the functions that return a string (i.e. \f(CW\*(C`const char *\*(C'\fR) in fact return
a pointer to statically allocated data inside the directory queue object.
The caller must use or copy the string before calling other functions since
they may override this statically allocated data.
.PP
Adding and getting elements (i.e. sequences of bytes) is achieved via
callback functions working on chunks of bytes so it is never needed to
allocate memory holding complete elements.
.PP
In case of error, the \f(CW\*(C`dirq_get_errcode\*(C'\fR and \f(CW\*(C`dirq_get_errstr\*(C'\fR functions
can be used to get more information. The safest approach is then to stop
using the object and free it. However, if needed, the error information can
be cleared with \f(CW\*(C`dirq_clear_error\*(C'\fR.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "dirq_t dirq_new (const char *path)" 4
.IX Item "dirq_t dirq_new (const char *path)"
creates a new directory queue object using the given path, setting the
internal error information (see \f(CW\*(C`dirq_get_errcode\*(C'\fR or \f(CW\*(C`dirq_get_errstr\*(C'\fR)
in case of error
.IP "dirq_t dirq_copy (dirq_t dirq)" 4
.IX Item "dirq_t dirq_copy (dirq_t dirq)"
creates a new directory queue object which is a copy of the given one
.IP "void dirq_free (dirq_t dirq)" 4
.IX Item "void dirq_free (dirq_t dirq)"
frees the memory associated with the directory queue object
.IP "void dirq_set_granularity (dirq_t dirq, int value)" 4
.IX Item "void dirq_set_granularity (dirq_t dirq, int value)"
sets the time granularity for intermediate directories
(default: 60)
.IP "int dirq_get_granularity (dirq_t dirq)" 4
.IX Item "int dirq_get_granularity (dirq_t dirq)"
gets the time granularity for intermediate directories
.IP "void dirq_set_rndhex (dirq_t dirq, int value)" 4
.IX Item "void dirq_set_rndhex (dirq_t dirq, int value)"
sets the random hexadecimal digit to use in element names
(default: randomly generated)
.IP "int dirq_get_rndhex (dirq_t dirq)" 4
.IX Item "int dirq_get_rndhex (dirq_t dirq)"
gets the random hexadecimal digit to use in element names
.IP "void dirq_set_umask (dirq_t dirq, mode_t value)" 4
.IX Item "void dirq_set_umask (dirq_t dirq, mode_t value)"
sets the umask to use when creating files and directories
(default: use the running process' umask)
.IP "mode_t dirq_get_umask (dirq_t dirq)" 4
.IX Item "mode_t dirq_get_umask (dirq_t dirq)"
gets the umask to use when creating files and directories
.IP "void dirq_set_maxlock (dirq_t dirq, int value)" 4
.IX Item "void dirq_set_maxlock (dirq_t dirq, int value)"
sets the maximum time for a locked element in seconds
(default 600)
.IP "int dirq_get_maxlock (dirq_t dirq)" 4
.IX Item "int dirq_get_maxlock (dirq_t dirq)"
gets the maximum time for a locked element in seconds
.IP "void dirq_set_maxtemp (dirq_t dirq, int value)" 4
.IX Item "void dirq_set_maxtemp (dirq_t dirq, int value)"
sets the maximum time for a temporary element in seconds
(default 300)
.IP "int dirq_get_maxtemp (dirq_t dirq)" 4
.IX Item "int dirq_get_maxtemp (dirq_t dirq)"
gets the maximum time for a temporary element in seconds
.IP "const char *dirq_first (dirq_t dirq)" 4
.IX Item "const char *dirq_first (dirq_t dirq)"
returns the first element in the queue, resetting the iterator;
returns \s-1NULL\s0 if the queue is empty or an error occurred
.IP "const char *dirq_next (dirq_t dirq)" 4
.IX Item "const char *dirq_next (dirq_t dirq)"
returns the next element in the queue, incrementing the iterator;
returns \s-1NULL\s0 if there is no next element or an error occurred
.IP "const char *dirq_add (dirq_t dirq, dirq_iow cb)" 4
.IX Item "const char *dirq_add (dirq_t dirq, dirq_iow cb)"
adds the given data (via callback) to the queue and returns the corresponding
element name or \s-1NULL\s0 on error
.IP "const char *dirq_add_path (dirq_t dirq, const char *path)" 4
.IX Item "const char *dirq_add_path (dirq_t dirq, const char *path)"
adds the given file (identified by its path) to the queue and returns the
corresponding element name or \s-1NULL\s0 on error, the file must be on the same
filesystem and will be moved to the queue
.IP "int dirq_get (dirq_t dirq, const char *name, dirq_ior cb)" 4
.IX Item "int dirq_get (dirq_t dirq, const char *name, dirq_ior cb)"
gets the data from the given element (which must be locked) via callback;
returns 0 on success, \-1 on error
.IP "const char *dirq_get_path (dirq_t dirq, const char *name)" 4
.IX Item "const char *dirq_get_path (dirq_t dirq, const char *name)"
gets the file path of the given element (which must be locked), this file
can be read but not removed, you must use the \fIremove()\fR method for this;
if the given name is \s-1NULL,\s0 returns the directory queue path itself
.IP "int dirq_lock (dirq_t dirq, const char *name, int permissive)" 4
.IX Item "int dirq_lock (dirq_t dirq, const char *name, int permissive)"
attempts to lock the given element and returns 0 on success;
in case of error, returns 1 (permissive) or \-1 (non permissive)
.IP "int dirq_unlock (dirq_t dirq, const char *name, int permissive)" 4
.IX Item "int dirq_unlock (dirq_t dirq, const char *name, int permissive)"
attempts to unlock the given element and returns 0 on success;
in case of error, returns 1 (permissive) or \-1 (non permissive)
.IP "int dirq_remove (dirq_t dirq, const char *name)" 4
.IX Item "int dirq_remove (dirq_t dirq, const char *name)"
removes the given element (which must be locked) from the queue;
returns 0 on success, \-1 on error
.IP "int dirq_touch (dirq_t dirq, const char *name)" 4
.IX Item "int dirq_touch (dirq_t dirq, const char *name)"
\&\*(L"touches\*(R" the given element (i.e. updates the access and modification times
to the current time); returns 0 on success, \-1 on error
.IP "int dirq_get_size (dirq_t dirq, const char *name)" 4
.IX Item "int dirq_get_size (dirq_t dirq, const char *name)"
returns the size (in bytes) of the given element or \-1 on error
.IP "int dirq_count (dirq_t dirq)" 4
.IX Item "int dirq_count (dirq_t dirq)"
returns the number of elements in the queue or \-1 on error;
this also resets the iterator
.IP "int dirq_purge (dirq_t dirq)" 4
.IX Item "int dirq_purge (dirq_t dirq)"
purges the queue by removing unused intermediate directories, removing too old
temporary elements and unlocking too old locked elements (aka staled locks);
this is using the \f(CW\*(C`maxlock\*(C'\fR and \f(CW\*(C`maxtemp\*(C'\fR attributes of the directory queue
object; returns the number of elements purged or \-1 on error; this also resets
the iterator
.IP "void dirq_now (dirq_t dirq, struct timespec *ts)" 4
.IX Item "void dirq_now (dirq_t dirq, struct timespec *ts)"
returns the current time in the given \f(CW\*(C`timespec\*(C'\fR structure
.IP "int dirq_get_errcode (dirq_t dirq)" 4
.IX Item "int dirq_get_errcode (dirq_t dirq)"
returns the current error code (usually \f(CW\*(C`errno\*(C'\fR) or 0 if there is no error
.IP "const char *dirq_get_errstr (dirq_t dirq)" 4
.IX Item "const char *dirq_get_errstr (dirq_t dirq)"
returns the current error string or \s-1NULL\s0 if there is no error
.IP "void dirq_clear_error (dirq_t dirq)" 4
.IX Item "void dirq_clear_error (dirq_t dirq)"
clears the current error
.SH "AUTHOR"
.IX Header "AUTHOR"
Lionel Cons <http://cern.ch/lionel.cons>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) \s-1CERN 2012\-2017\s0
